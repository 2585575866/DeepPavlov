# Задача разрешения корреференции (на русском языке)

## Описание архитектуры

Для решения задачи разрешения корреференции на русском языке использована архитектура представленная в статье
[End-to-end Neural Coreference Resolution](https://arxiv.org/abs/1707.07045). Архитектуру можно разделить условно на три
блока, первый блок представляет из себя несколько двунаправленных реккурентных слоёв, осуществляющих первичную обработку
поступающих на вход предложений в векторном виде. Также к первому блоку можно отнести свёрточную сеть которая обучается 
формировать эмбеддинги на символьном уровне. Второй блок представляет из себя набор полносвязных сетей отвечающих за 
определение границ упоминаний в тексте, а также формирование ембеддингов для отдельных кластеров. Третий блок также 
представляет из себя полносвязную сеть, отвечающую за финальную разметку упоминаний в тексте.

Данная архитектура способна сама определять границы упоминаний в тексте, за счёт этого модель может работать как с 
размеченными данными, в которых определны границы упоминаний, и требуется только правильно их разметить,
так и с неразмеченным текстом. На вход модель принимает векторные представления (embeddings) токенов полученных с помощью fasttext
модели, обученной на большом текстовом корпусе.

## Описание данных

Модель обучается на датасете [RuCor](http://rucoref.maimbava.net/), переведенным в conll формат 2012 года. После 
предобработки он представляет из себя случайно разбитый (0,8/0,1/0,1) на train/valid/test набор файлов в conll формате. 

Пример файла в conll формате:
```
#begin document (10); part 0
10      0       0       Когда   C       -       когда   -       spk1    -       -       -
10      0       1       мы      P-1-pnn -       мы      -       spk1    -       -       (867)
10      0       2       шли     Vmis-p-a-e      -       идти    -       spk1    -       -       -
10      0       3       по      Sp-d    -       по      -       spk1    -       -       -
10      0       4       тропинке        Ncfsdn  -       тропинка        -       spk1    -       -       -
10      0       5       ,       ,       -       ,       -       spk1    -       -       -
10      0       6       каждый  P--msna -       каждый  -       spk1    -       -       -
10      0       7       был     Vmis-sma-e      -       быть    -       spk1    -       -       -
10      0       8       доволен Afpmsns -       довольный       -       spk1    -       -       -
10      0       9       и       C       -       и       -       spk1    -       -       -
10      0       10      думал   Vmis-sma-e      -       думать  -       spk1    -       -       -
10      0       11      ,       ,       -       ,       -       spk1    -       -       -
10      0       12      что     C       -       что     -       spk1    -       -       -
10      0       13      надул   Vmis-sma-p      -       надуть  -       spk1    -       -       -
10      0       14      другого P--msaa -       другой  -       spk1    -       -       -
10      0       15      .       SENT    -       .       -       spk1    -       -       -

10	0	0	Петька	Npmsny	-	петька	-	spk1	-	-	(870)
10	0	1	изредка	R	-	изредка	-	spk1	-	-	-
10	0	2	посапывал	Vmis-sma-e	-	посапывать	-	spk1	-	-	-
10	0	3	носом	Ncmsin	-	нос	-	spk1	-	-	-
10	0	4	.	SENT	-	.	-	spk1	-	-	-

10	0	0	Давно	R	-	давно	-	spk1	-	-	-
10	0	1	он	P-3msnn	-	он	-	spk1	-	-	(870)
10	0	2	зарился	Vmis-smm-p	-	зарился	-	spk1	-	-	-
10	0	3	на	Sp-a	-	на	-	spk1	-	-	-
10	0	4	моих	P---paa	-	мой	-	spk1	-	-	(869)|(859
10	0	5	голубей	Ncmpgy	-	голубь	-	spk1	-	-	859)
10	0	6	,	,	-	,	-	spk1	-	-	-
10	0	7	еще	R	-	еще	-	spk1	-	-	-
10	0	8	с	Sp-g	-	с	-	spk1	-	-	-
10	0	9	прошлой	Afpfsgf	-	прошлый	-	spk1	-	-	-
10	0	10	зимы	Ncfsgn	-	зима	-	spk1	-	-	-
10	0	11	,	,	-	,	-	spk1	-	-	-
10	0	12	а	C	-	а	-	spk1	-	-	-
10	0	13	теперь	P-----r	-	теперь	-	spk1	-	-	-
10	0	14	вот	Q	-	вот	-	spk1	-	-	-
10	0	15	счастье	Ncnsnn	-	счастье	-	spk1	-	-	-
10	0	16	неожиданно	R	-	неожиданно	-	spk1	-	-	-
10	0	17	привалило	Vmis-sna-p	-	привалить	-	spk1	-	-	-
10	0	18	.	SENT	-	.	-	spk1	-	-	-

10	0	0	А	C	-	а	-	spk1	-	-	-
10	0	1	у	Sp-g	-	у	-	spk1	-	-	-
10	0	2	меня	P-1-sgn	-	я	-	spk1	-	-	(869)
10	0	3	будет	Vmif3s-a-e	-	быть	-	spk1	-	-	-
10	0	4	пистолет	Ncmsan	-	пистолет	-	spk1	-	-	(868)
10	0	5	.	SENT	-	.	-	spk1	-	-	-

                                                        *     *     *
                                                        *     *     *
                                                        *     *     *

10	0	0	В	Sp-a	-	в	-	spk1	-	-	-
10	0	1	окно	Ncnsan	-	окно	-	spk1	-	-	-
10	0	2	радостно	R	-	радостно	-	spk1	-	-	-
10	0	3	,	,	-	,	-	spk1	-	-	-
10	0	4	по	Sp-d	-	по	-	spk1	-	-	-
10	0	5	-	-	-	-	-	spk1	-	-	-
10	0	6	весеннему	Afpmsdf	-	весенний	-	spk1	-	-	-
10	0	7	светило	Vmis-sna-e	-	светить	-	spk1	-	-	-
10	0	8	утреннее	Afpnsnf	-	утренний	-	spk1	-	-	-
10	0	9	солнце	Ncnsnn	-	солнце	-	spk1	-	-	-
10	0	10	.	SENT	-	.	-	spk1	-	-	-

#end document
```

Сама модель и при обучении, и при запуске модели в режиме `inference` принимает на вход содержание conll файла в виде 
строки. И возвращает также строку содержащую размеченный conll файл.

## Параметры модели
* Размерность векторных представлений токенов: 300
* Размерность посимвольных векторных представлений токенов: 8
* Максимальная длина упоминаний (в токенах): 10
* Максимальное число предложений в примере: 50
* Максимальное количество антецендентов: 250
* Ширина фильтров: (3, 4, 5)
* Размер фильтров: 50
* Размерность дополнительных фичей: 20
* Размерность скрытого слоя одного направления GRU: 200
* Размерность полносвязного слоя: 150
* Количество слоёв в полносвязных сетях: 2
* Dropout rate: 0.2
* Dropout rate for CNN: 0.5
* Learning rate: 0.001
* Decay_frequency: 100
* Decay: 0.999
* Final_rate: 0.0002
* Optimizer: "adam"
* Max_gradient_norm: 5.0
* Размер батча: 1
* Количество эпох: 100 (используется early stopping)
* Валидация каждый `n` эпох: 1
* Patience для целевой метрики: 15

## Запуск модели
Перед запуском модели необходимо сперва загрузить векторные представления слов с помощью команды:

    python -m deeppavlov download deeppavlov/configs/coreference_resolution/coref_full.json 

В папку `~/.deeppavlov/download/` будут загружены все необходимые файлы, а именно эмбеддинги, в папку 
`~/.deeppavlov/download/embeddings/` соответственно, и датасет с уже обученной моделью в папки `~/.deeppavlov/download/coreference_resolution/rucoref_29.10.2015` и 
`~/.deeppavlov/download/coreference/checkpoints/` соответственно. Загрузка производится всего один раз. 
При последующих запусках на инференс производить загрузку не нужно.

Также требуется установить все необходимые зависимости для работы модели:

    python -m deeppavlov install .deeppavlov/configs/coreference_resolution/coref_full.json

### Компилирование tf операций написанных на C++
Кроме того, для корректной работы модели требуется скомпилировать специальные операции tensorflow, написанные на 
C++. Для этого необходимо выполнить в командной строке следующие операции:

    TF_CFLAGS=( $(python -c 'import tensorflow as tf; print(" ".join(tf.sysconfig.get_compile_flags()))') )

    TF_LFLAGS=( $(python -c 'import tensorflow as tf; print(" ".join(tf.sysconfig.get_link_flags()))') )

После чего перейти в папку "./deepreply/models/coreference/", и выполнить команду:

    g++ -std=c++11 -shared coref_kernels.cc -o coref_kernels.so -fPIC ${TF_CFLAGS[@]} ${TF_LFLAGS[@]} -O2

После успешной компиляции в папке появится новый файл "coref_kernels.so", теперь можно запускать модель на обучение, 
или в интерактивном режиме.

### Командная строка

Для запуска модели в интерактивном режиме из командной используется следующая команда:

    python -m deeppavlov interact deeppavlov/configs/coreference_resolution/coref_full.json

Замечание: помните что модель принимает на вход строку в формате conll. 
### Python

Для использования модели в python коде можно использовать следующий код:

```python
import json
from deeppavlov import build_model

file_name = "./download/rucor_conll/test/10.gold_conll"
with open(file_name, "r", encoding='utf8') as f:
    x = f.read()

PIPELINE_CONFIG_PATH = '/deepreply/configs/coreference_kpi11/coreference_russian_conll.json'
with open(PIPELINE_CONFIG_PATH) as f:
    config = json.load(f)
model = build_model(config)
model(x)
```

## Тренировка модели
 
в папке `~/.deeppavlov/download/coreference_resolution/rucor_conll` должны находиться папки с именами `train`, 
`valid`, `test` содержащие соответствующие данные в формате `gold_conll`. Пример данных был приведён выше.

Если необходимо обучить модель заново, то следует изменить `save_path` и `load_path` для модели в конфиге, либо удалить
все существующие чекпоинты и промежуточные файлы. После чего выполнить в командной строке команду:

    python -m deeppavlov train deeppavlov/configs/coreference_resolution/coref_full.json

## Эвалюация
Для оценки качества модели используется общепринятый [скрипт](https://github.com/conll/reference-coreference-scorers) 
с международного соревнования по разрешению кореференции 2012 года. Для вычисления метрик достаточно выполнить в
командной строке команду:

```bash
python -m deeppavlov evaluate deeppavlov/configs/coreference_resolution/coref_full.json
```
Результат эвалюации будет выведен в консоль. Вывод:

```bash
{"valid": {"eval_examples_count": 36, "metrics": {"coref_f1": 73.9507}, "time_spent": "0:00:55"}}
{"test": {"eval_examples_count": 37, "metrics": {"coref_f1": 77.3904}, "time_spent": "0:00:49"}}
```

Для оценки качества модели на своих данных, подготовьте набор тестовых файлов в формате разметки 
[CoNLL](http://conll.cemantix.org/2012/data.html) (можете ориентироваться на пример документа, что приведён выше), 
укажите в конфиге новый путь к папке с тестовыми файлами, и запустите ту же команду. Если не планируете вычислять 
метрику для валидационной части датасета, то укажите ключу "validate_best" значение "false".